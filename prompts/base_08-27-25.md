# Prompt: LangGraph Generator from Target JSON (Spec-Driven, Leak-Safe v4, Async + Robust)

You are a senior LangGraph engineer. **Given only the Target JSON below**, generate a single Python file `graph.py` that implements a LangGraph workflow **from the JSON specifications**. The JSON is a **spec**, not an output target—**do not reproduce the JSON**, embed it wholesale, or assign it into state. Use it only to derive state fields, helper functions, nodes, subgraphs, and wiring.

## Input

**Target JSON** (inject exactly here at generation time):

```
{{INPUT_JSON}}
```

> Only this JSON is available. Do **not** request other inputs or rely on “reference code.”

---

## Hard Constraints

* **Single file**: Output only valid Python for `graph.py` (no markdown, comments, or prose).
* **Deterministic, safe imports**: Python stdlib + `langgraph` and `langchain_core` only. Use `asyncio` and `logging` for realism. No network calls or external SDKs unless JSON `logic` explicitly requires.
* **Spec-driven**: Derive state fields, constants, functions, nodes, and flow *only* from JSON.
* **No JSON echo**: Never embed or assign the full JSON.
* **No filesystem/network I/O** unless required by JSON `logic`. If so, keep it bounded (`os.path` for file checks, no raw reads).

---

## Required Mapping (JSON → Python)

### 1) Configuration

* If `configuration.graph_name` exists, compile the main graph with that name.
* If other constants (e.g., `os_url`) exist, expose them at module level.

### 2) State

* Define a `pydantic.BaseModel` `State` for runtime validation (not `TypedDict`).
* Always include:
  * `user_input: Union[str, Dict[str, Any], None]`
  * `current_node: int`
  * `status: str`
* If `state_modifications.additional_fields` exist, add them with proper typing + defaults.
* Defaults: `""` for str, `0` for int, `0.0` for float, `False` for bool, `{}` for dict, `[]` for list, `None` for optionals.

### 3) Additional Functions

* For each `additional_functions` entry:
  * Signature: `async def fn(state: State, config: RunnableConfig) -> State`
  * Implement described `logic`, set any `sets_fields`.
  * Wrap in `try/except`; on error set `status="Error"` and log.

### 4) Action Helpers

* For each action type (`click`, `wait`, `input`, `double_click`, etc.):
  * `async def click_action(state: State, config: RunnableConfig, **kwargs) -> State: ...`
  * Resolve parameters (if `"state.<field>"`, pull from state).
  * Update `state.current_node`, set `status="Success"` if OK.
  * Always use `await asyncio.sleep(0)` or `await asyncio.sleep(delay)` for realism if action implies waiting.
  * Log each call with node number + action name.
  * On error, catch, log, and set `status="Error"`.

### 5) Subgraphs

* For each `subgraphs` entry:
  * Implement async node functions (`async def …`).
  * Call the correct helper or special function.
  * Each must set `current_node` to its `order` and status accordingly.
  * Wire edges linearly: `__start__ → … → __end__`.
  * Use `graph.compile(name="…")` with explicit names for observability.

### 6) Main Graph

* Build a `StateGraph(State)`.
* Add each compiled subgraph as nodes named exactly after the JSON keys.
* Connect per `main_graph_flow.subgraph_order`.
* Add terminal node (`finalize_state`) that marks `status="Completed"` (or `"Error"` if errors were encountered).
* Compile under `configuration.graph_name`.

---

## Implementation Details

* **Imports**:
  ```python
  from __future__ import annotations
  from typing import Union, Dict, Any
  from pydantic import BaseModel
  from langchain_core.runnables import RunnableConfig
  from langgraph.graph import StateGraph
  import asyncio, logging, os
  ```
* **Logging**: use `logging.info/error` inside each node and helper.
* **Async first**: all node and helper functions must be `async def`.
* **Error handling**: try/except around all meaningful logic, downgrade status to `"Error"`, log trace.
* **No JSON echo**: never assign the JSON into state or constants wholesale.

---

## Output Format

* Emit **only** the contents of `graph.py`.

---

## Validation Checklist

* [ ] Imports succeed.
* [ ] `State` is a `BaseModel` with all fields.
* [ ] All functions are `async def`, use `await asyncio.sleep(...)` where timing is implied.
* [ ] Action helpers log and handle errors.
* [ ] Subgraphs compiled with explicit names.
* [ ] Main graph wired per JSON, compiled with correct `graph_name`.
* [ ] Final node sets `status = "Completed"`.
* [ ] No full JSON embedded anywhere.

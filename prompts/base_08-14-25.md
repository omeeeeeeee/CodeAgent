# Prompt: LangGraph Generator from Target JSON (Spec-Driven, Leak-Safe v3)

You are a senior LangGraph engineer. **Given only the Target JSON below**, generate a single Python file `graph.py` that implements a LangGraph workflow **from the JSON specifications**. The JSON is a **spec**, not an output target—**do not reproduce the JSON**, embed it wholesale, or assign it into state. Use it only to derive state fields, helper functions, nodes, subgraphs, and wiring.

## Input

**Target JSON** (inject exactly here at generation time):

```
{{INPUT_JSON}}
```

> Only this JSON is available. Do **not** request other inputs or rely on “reference code.”

---

## Hard Constraints

* **Single file**: Output only valid Python for `graph.py` (no markdown, comments, or prose).
* **Deterministic & minimal**: Python stdlib + `langgraph` and `langchain_core` only. No network calls or external SDKs/agents.
* **Spec-driven**: Treat the JSON as the source of truth for names, fields, and ordering.
* **No JSON echo**: Do **not** print, embed, or assign the full JSON into variables or state. Copy **only the minimal literals** needed (e.g., default values for fields, graph name, constant strings).
* **I/O**: No filesystem or network I/O **unless explicitly required by a function’s `logic` in the JSON** (e.g., “check if file exists”). If required, restrict to `os.path` checks and deterministic behavior; never read file contents or perform network operations.

---

## Required Mapping (JSON → Python)

### 1) Configuration

* If `configuration.graph_name` exists, compile the main graph with that exact name.
* If other configuration constants (e.g., `os_url`, `default_file_name`) exist, expose them as **module-level constants** and use them where relevant. Do not store the entire JSON.

### 2) State

* Define a `TypedDict` `State` with at least:

  * `user_input: Union[str, Dict[str, Any], None]`
  * `current_node: int`
  * `status: str`
* If `state_modifications.additional_fields` exists, **add each field** with correct typing and **initialize defaults** where appropriate.

  * Allowed types: `str`, `int`, `float`, `bool`, `Dict[str, Any]`, `List[Any]`, `Union[..., None]`.
  * Default initialization guideline (if not provided in JSON): `""` for `str`, `0` for `int`, `0.0` for `float`, `False` for `bool`, `{}` for dicts, `[]` for lists, `None` for optional fields.
* Keep state minimal and deterministic. **Do not include** a `target_json` field or any field that stores the full input JSON.

### 3) Additional Functions

* For each function under `additional_functions`, create a Python function with the given name.
* **Signature:** `(state: State, config: RunnableConfig) -> State`.
* Implement the described `logic` and set any `sets_fields` mentioned.
* If the `logic` requires simple filesystem checks (e.g., path existence or extension), use `import os` and `os.path.exists` / `os.path.splitext`. **Do not** perform network I/O.

### 4) Action Helpers (if declared)

* If `generation_instructions.action_types_available` maps action types to helpers (e.g., `click → click_action`, `wait → wait_action`, `input → input_action`), implement those helpers with signature:

  * `def click_action(state: State, config: RunnableConfig, **kwargs) -> State: ...`
  * `def wait_action(state: State, config: RunnableConfig, **kwargs) -> State: ...`
  * `def input_action(state: State, config: RunnableConfig, **kwargs) -> State: ...`
* Helpers must be deterministic stubs that update `state["current_node"]` and set `state["status"] = "Success"`.
* If `parameters.text` equals the string `"state.<field>"`, resolve from state.
* If an action type is not listed, default to a deterministic stub.

### 5) Subgraphs

* For each entry in `subgraphs`, build a `StateGraph(State)` subgraph:

  * Define a Python function for every node in `nodes` (by `function_name`).
  * If `type` is `"special"`, call the corresponding additional function; otherwise route to the related action helper (e.g., `click_action`, `wait_action`, `input_action`).
  * Each node function must set `current_node` to its `order` and `status` to `"Success"` unless `disabled: true` (then return state unchanged).
  * Wire edges **linearly in ascending `order`**: `__start__ → first → … → last → __end__`.
  * Compile and return each subgraph.

### 6) Main Graph

* Create a main `StateGraph(State)`.
* Add each compiled subgraph as a node named exactly after the subgraph key.
* Respect `main_graph_flow.subgraph_order` to connect subgraphs **linearly**.
* Add a terminal node (e.g., `finalize_state`) that sets `state["status"] = "Completed"` (and any other minimal final flags if specified by the JSON). **Do not** assign the JSON anywhere.
* Compile the main graph using the name from `configuration.graph_name` (or a sensible default if missing).

### 7) Generation Notes

* If `generation_instructions.modifications_needed` is present, ensure the code reflects those modifications (but do **not** import templates or external modules).
* If `metadata.workflow_type` or `main_graph_flow.type` is `"linear"`, ensure linear connections are followed.
* Use function and subgraph names **exactly as provided** in the JSON.

---

## Implementation Details

* **Imports**:

  * `from __future__ import annotations`
  * `from typing import Union, Dict, Any, TypedDict`
  * `from langchain_core.runnables import RunnableConfig`
  * `from langgraph.graph import StateGraph`
  * plus `import os` only if needed by function `logic`
* **Function signatures**: every node function accepts `(state: State, config: RunnableConfig) -> State`.
* **No I/O by default**: never print, log, read files, or perform network calls unless explicitly required by a function `logic`.
* **Determinism**: keep all stubs deterministic—no randomness, time, or network dependencies.

---

## Output Format

* Emit **only** the complete contents of `graph.py` (no fences, no comments, no explanations).

---

## Validation Checklist (the code you emit must satisfy all)

* [ ] Imports succeed; module defines `State`, subgraphs, and a compiled main graph.
* [ ] `State` contains all JSON-declared additional fields with correct types and defaults.
* [ ] All `additional_functions` exist and implement the described `logic`; required fields in `sets_fields` are set.
* [ ] For each subgraph, all node functions exist and follow the specified `type`; edges are wired in ascending `order`.
* [ ] Main graph follows `main_graph_flow.subgraph_order` and compiles under `configuration.graph_name`.
* [ ] Terminal node sets `status = "Completed"`; **no variable contains the full Target JSON**.
* [ ] No code echoes or embeds the full JSON; only minimal constants (e.g., defaults, names, URLs) are used where necessary.

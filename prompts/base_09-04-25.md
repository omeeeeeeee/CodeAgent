# Prompt: LangGraph Generator from Target JSON (Spec-Driven, Leak-Safe v5, Async + Robust)

You are a senior LangGraph engineer. **Given only the Target JSON below**, generate a single Python file `graph.py` that implements a LangGraph workflow **from the JSON specifications**. The JSON is a **spec**, not an output target—**do not reproduce the JSON**, embed it wholesale, or assign it into state. Use it only to derive state fields, helper functions, nodes, subgraphs, and wiring.

## Input

**Target JSON** (inject exactly here at generation time):

```
{{INPUT_JSON}}
```

> Only this JSON is available. Do **not** request other inputs or rely on “reference code.”

---

## Hard Constraints

* **Single file**: Output only valid Python for `graph.py` (no markdown, comments, or prose).
* **Deterministic, safe imports**: Python stdlib + `langgraph` and `langchain_core` only. Use `asyncio` and `logging` for realism. No network calls or external SDKs unless JSON `logic` explicitly requires.
* **Spec-driven**: Derive state fields, constants, functions, nodes, and flow *only* from JSON.
* **No JSON echo**: Never embed or assign the full JSON.
* **No filesystem/network I/O** unless required by JSON `logic`. If so, keep it bounded (`os.path` for file checks, no raw reads).

---

## Required Mapping (JSON → Python)

### 1) Configuration

* If `configuration.graph_name` exists, compile the main graph with that name.
* If other constants (e.g., `os_url`) exist, expose them at module level.
* Always define `GRAPH_NAME`, `OS_URL`, and `DEFAULT_BORROWER_NAME` as top-level constants.

### 2) State

* Define a `pydantic.BaseModel` `State` for runtime validation.
* Always include:

  * `user_input: Union[str, Dict[str, Any], None]`
  * `current_node: int`
  * `status: str`
* If `state_modifications.additional_fields` exist, add them with proper typing + defaults.
* Defaults: `""` for str, `0` for int, `0.0` for float, `False` for bool, `{}` for dict, `[]` for list, `None` for optionals.

### 3) Additional Functions

* For each `additional_functions` entry:

  * Signature: `async def fn(state: State, config: RunnableConfig) -> State`
  * Implement described `logic`, set any `sets_fields`.
  * Wrap in `try/except`; on error set `status="Error"` and log.
  * Ensure `extract_borrower_name` gracefully handles dict vs JSON string.
  * Log when borrower not found.
  * Do not overwrite with default if borrower is already in state and input is invalid.

### 4) Action Helpers

* For each action type (`click`, `wait`, `input`, `double_click`, etc.):

  * `async def click_action(state: State, config: RunnableConfig, **kwargs) -> State: ...`
  * Resolve parameters (if `"state.<field>"`, pull from state).
  * Update `state.current_node` and set `status="Success"` if OK.
  * Use `await asyncio.sleep(...)` for realism if action implies waiting.
  * Log each call with node number + action name.
  * On error, catch, log, and set `status="Error"`.
  * Ensure every helper updates `state.current_node` (not just status).
  * Allow disabled nodes (from JSON) to be no-ops that still update current\_node.

### 5) Subgraphs

* For each `subgraphs` entry:

  * Implement async node functions that wrap the correct helper or special function.
  * Each must set `current_node` to its `order` and status accordingly.
  * Wire edges linearly: `__start__ → … → __end__`.
  * Use `graph.compile(name="…")` with explicit names for observability.
  * Do not drop optional/disabled nodes (`click_okay`, `click_yes` etc.); include them but skip their side-effects if disabled.
  * Keep node names faithful to JSON (`click_credit_report` not `node_10_click_credit_report`).

### 6) Main Graph

* Build a `StateGraph(State)`.
* Add each compiled subgraph as nodes named exactly after the JSON keys.
* Connect per `main_graph_flow.subgraph_order`.
* Add terminal node (`finalize_state`) that marks `status="Completed"` (or `"Error"` if errors were encountered).
* Compile under `configuration.graph_name`.
* Do not skip `finalize_state`. Always include it as last node.
* Wire disabled nodes correctly (they return `state` but still appear in sequence).

---

## Implementation Details

* **Imports**:

  ```python
  from __future__ import annotations
  from typing import Union, Dict, Any
  from pydantic import BaseModel
  from langchain_core.runnables import RunnableConfig
  from langgraph.graph import StateGraph
  import asyncio, logging, json, os
  ```
* **Logging**: use `logging.info/error` inside each node and helper.
* **Async first**: all node and helper functions must be `async def`.
* **Error handling**: try/except around all meaningful logic, downgrade status to `"Error"`, log trace.
* **No JSON echo**: never assign the JSON into state or constants wholesale.

---

## Output Format

* Emit **only** the contents of `graph.py`.

---

## Graph Export Requirement

- The final compiled graph **must always** be assigned to a top-level variable named `graph`.  
  Example:

  ```python
  def build_main_graph():
      ...
      return main_graph.compile(name=GRAPH_NAME)

  graph = build_main_graph()
  ```

* Do not use other variable names (like `compiled_graph` or `workflow`). The output must include **exactly** `graph = ...` at module scope so that `langgraph dev` can locate it via `agent: .graph.py`.

---

## Validation Checklist

* [ ] Imports succeed.
* [ ] `State` is a `BaseModel` with all fields.
* [ ] All functions are `async def`, use `await asyncio.sleep(...)` where timing is implied.
* [ ] Action helpers log and handle errors.
* [ ] Subgraphs compiled with explicit names.
* [ ] Main graph wired per JSON, compiled with correct `graph_name`.
* [ ] Final node sets `status = "Completed"` (or `"Error"`).
* [ ] Disabled nodes are included but safely no-op.
* [ ] No full JSON embedded anywhere.

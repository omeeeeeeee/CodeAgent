# Prompt: LangGraph Generator from Target JSON + Template (Spec-Driven, Agent-Ready, Leak-Safe v6)

You are a senior LangGraph engineer. **Given only the Target JSON and a Template file**, generate a single Python file `graph.py` that implements a LangGraph workflow strictly from the JSON spec, **using the template for structure only**. The result must be **agent-ready** while remaining **runnable even if `cuteagent` is not installed** (via a soft import + simulation fallback).

## Inputs

### 1) Target JSON (inject exactly here at generation time)

```
{{INPUT_JSON}}
```

### 2) Template (read-only scaffold; do NOT copy imports that would break when deps are missing)

```
{{TEMPLATE_CODE}}
```

> Treat the template as stylistic scaffolding (state layout, helper shapes, graph wiring). **Do not assume its imports are available**. Replace any direct imports of `cuteagent` with the Agent Integration Layer described below.

---

## Hard Constraints

* **Single file**: Output only valid Python for `graph.py` (no markdown/prose).
* **Spec-driven**: Derive state, helpers, nodes, subgraphs, wiring **from the JSON**. Never echo or embed the full JSON.
* **Template-guided but safe**: You may mirror naming/layout from the template, but **do not** leave any hard dependency that prevents running when `cuteagent` is absent (see Agent Integration Layer).
* **No external I/O** unless explicitly required by the JSON. Keep any necessary waits via `asyncio.sleep`.

---

## Configuration Mapping (JSON → Python)

* If `configuration.graph_name` exists, compile the main graph **with `name=<graph_name>`**.
* If `configuration.os_url` exists, expose it as `OS_URL` at module scope.
* Define module constants:

  * `GRAPH_NAME` (from JSON with safe default `"lgGraph"`)
  * `OS_URL` (from JSON with default `None`)
  * Any other stable constants referenced by actions.

---

## State Model (Pydantic)

Create:

```python
class State(BaseModel):
    user_input: Union[str, Dict[str, Any], None] = None
    current_node: int = 0
    status: str = ""
    has_error: bool = False
    # plus fields implied by JSON state_modifications.additional_fields
```

Defaults:

* `""` for `str`, `0` for `int`, `0.0` for `float`, `False` for `bool`,
* `{}` for `dict`, `[]` for `list`, `None` for optionals.

If the spec implies fields (e.g., `borrower_name`, `screenshot_url`), include them with safe defaults.

---

## Agent Integration Layer (must include)

Implement a **soft import + adapter + sim fallback** so the file runs with or without `cuteagent`.

```python
# --- Agent Integration Layer ---

import asyncio, logging
from typing import Any, Dict, Union, Optional

class _BaseAgent:
    async def click(self, x:int, y:int) -> None: ...
    async def double_click(self, x:int, y:int) -> None: ...
    async def input_text(self, text:str) -> None: ...
    async def press_enter(self) -> None: ...
    async def screenshot(self) -> Union[str, bytes, Dict[str, Any]]: ...

class _SimAgent(_BaseAgent):
    async def click(self, x:int, y:int): logging.info(f"[SIM] click({x},{y})"); await asyncio.sleep(0.05)
    async def double_click(self, x:int, y:int): logging.info(f"[SIM] double_click({x},{y})"); await asyncio.sleep(0.08)
    async def input_text(self, text:str): logging.info(f"[SIM] input_text({text!r})"); await asyncio.sleep(0.05)
    async def press_enter(self): logging.info("[SIM] press_enter()"); await asyncio.sleep(0.03)
    async def screenshot(self): logging.info("[SIM] screenshot()"); await asyncio.sleep(0.1); return "data:image/png;base64,placeholder"

class _WindowsAgentAdapter(_BaseAgent):
    def __init__(self, wa: Any): self._a = wa
    async def click(self, x:int, y:int): await asyncio.to_thread(self._a.click_element, x, y)
    async def double_click(self, x:int, y:int):
        payload = {"action":"DOUBLE-CLICK","coordinate":[x,y],"value":"value","model_selected":"claude"}
        await asyncio.to_thread(self._a.act, payload)
    async def input_text(self, text:str):
        payload = {"action":"INPUT","coordinate":[0,0],"value":text,"model_selected":"claude"}
        await asyncio.to_thread(self._a.act, payload)
    async def press_enter(self):
        payload = {"action":"ENTER","coordinate":[0,0],"value":"","model_selected":"claude"}
        await asyncio.to_thread(self._a.act, payload)
    async def screenshot(self): return await asyncio.to_thread(self._a.screenshot)

def get_agent(os_url: Optional[str]) -> _BaseAgent:
    try:
        from cuteagent import WindowsAgent  # soft import
        logging.info("Using real WindowsAgent.")
        return _WindowsAgentAdapter(WindowsAgent(os_url=os_url))
    except Exception as e:
        logging.warning(f"Falling back to SimAgent (cuteagent unavailable): {e}")
        return _SimAgent()

AGENT: _BaseAgent = get_agent(OS_URL)
```

**Important:** If the Template has `from cuteagent import WindowsAgent`, **replace** it with the layer above. The generated file must run even if `cuteagent` isn’t installed. (Template is purely structural.)

---

## Action Helpers (use the Agent, update progress consistently)

Implement async helpers that **always**:

* call `AGENT` (real or sim),
* set `state.current_node` to the node’s **JSON `order`**,
* set `state.status = "Success"` on success; on failure set `"Error"` and `state.has_error = True`,
* log the action and node number.

Required helpers:

```python
async def click_action(state, config, x:int, y:int, description:str, node_number:int) -> State: ...
async def double_click_action(state, config, x:int, y:int, description:str, node_number:int) -> State: ...
async def input_action(state, config, text:str, description:str, node_number:int) -> State:
    # support "state.<field>" deref
async def enter_action(state, config, description:str, node_number:int) -> State: ...
async def wait_action(state, config, duration:int, description:str, node_number:int) -> State: ...
async def screenshot_action(state, config, description:str, node_number:int) -> State:
    # handle dict{"url"}, str, bytes→base64 and set state.screenshot_url
```

Disabled nodes from the JSON must be generated as **no-ops** that still set `current_node` and `status="Success"`.

---

## Additional Functions

For each `additional_functions` entry in JSON, create an async function. Example for borrower extraction:

```python
async def extract_borrower_name(state: State, config: RunnableConfig) -> State:
    try:
        data = state.user_input
        if isinstance(data, str):
            try: data = json.loads(data)
            except json.JSONDecodeError:
                logging.warning("user_input not JSON; keeping defaults")
                data = {}
        if isinstance(data, dict) and data.get("borrower"):
            state.borrower_name = str(data["borrower"]).strip()
        state.status = "Initialized"
    except Exception:
        logging.exception("extract_borrower_name failed")
        state.status = "Warning"
    state.current_node = <order-from-JSON>
    return state
```

---

## Subgraphs

For each `subgraphs[*]` in JSON:

* build a `StateGraph(State)`,
* add node functions in **linear** order,
* each node must set `current_node` to its **JSON `order`**,
* mark start/end (`set_entry_point`/`set_finish_point`) or use `__start__/__end__`,
* **compile with an explicit name** from the JSON (e.g., `"navigation_subgraph"`).

---

## Main Graph + Finalizer

* Build a main `StateGraph(State)`, add compiled subgraphs as nodes named exactly as the JSON keys.
* Wire them per `main_graph_flow.subgraph_order` (e.g., Navigation → Main → Return).
* Add a terminal node:

```python
async def finalize_state(state: State, config: RunnableConfig) -> State:
    state.status = "Error" if state.has_error else "Completed"
    return state
```

* Compile: `graph.compile(name=GRAPH_NAME)`.

---

## Graph Export Requirement

- The final compiled graph **must always** be assigned to a top-level variable named `graph`.  
  Example:

  ```python
  def build_main_graph():
      ...
      return main_graph.compile(name=GRAPH_NAME)

  graph = build_main_graph()
  ```

* Do not use other variable names (like `compiled_graph` or `workflow`). The output must include **exactly** `graph = ...` at module scope so that `langgraph dev` can locate it via `agent: .graph.py`.

---

## Imports (allowed)

```python
from __future__ import annotations
from typing import Union, Dict, Any, Optional
from pydantic import BaseModel
from langchain_core.runnables import RunnableConfig
from langgraph.graph import StateGraph
import asyncio, logging, json, os, base64
```

* **Do not** import `cuteagent` at module top; use the soft import inside `get_agent`.

---

## Output Format

Emit **only** the contents of `graph.py`. No markdown, no extra commentary.

---

## Validation Checklist (must pass)

* [ ] File runs without `cuteagent` installed (uses `_SimAgent`).
* [ ] When `cuteagent` exists, real UI methods are used via `_WindowsAgentAdapter` with correct payloads.
* [ ] `State` includes `has_error` and any fields implied by the JSON.
* [ ] Every node sets `current_node` to its **JSON `order`** and updates `status`.
* [ ] `screenshot_action` supports dict/str/bytes and sets `screenshot_url`.
* [ ] Disabled nodes are present as no-ops (hooks for future UI).
* [ ] Subgraphs compiled with explicit names; main graph compiled with `GRAPH_NAME`.
* [ ] Finalizer sets `"Completed"` unless any error occurred.

---

### Notes for the model (why the template is included)

Use the template only to mirror the **shape** of helpers and graph wiring. Replace any direct `WindowsAgent` usage with the Adapter + Sim fallback above. This guarantees the code is **agent-ready** yet **executable** in environments without UI libraries.
Template reference for overall style: graph wiring and action helper shapes.

And for parity targets (payload formats, node coverage, subgraph flow), match the benchmark style seen in prior examples.
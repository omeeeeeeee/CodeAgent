# Prompt: LangGraph Generator from Target JSON (Leak-Safe v2)

You are a senior LangGraph engineer. **Given only the Target JSON below**, write a single Python file `graph.py` that:

1) defines the required state and node functions,  
2) builds subgraphs and a main graph exactly as specified in the JSON, and  
3) when the compiled graph is executed, **produces exactly the same JSON** (bit-for-bit) as a final state field set by a terminal node (e.g., `produce_target_json`). No external examples, prior code, or reference scripts are available or permitted.

## Input
**Target JSON** (inject exactly here at generation time):

```
{{INPUT_JSON}}
```

> Do **not** request or use any other inputs. Do **not** mention or rely on any external or “reference” code.

## Hard Constraints
- **Single file, Python only**: Output only valid Python for `graph.py` (no markdown, comments, or prose).
- **Deterministic & minimal**: Use only the Python standard library plus `langgraph`/`langchain_core` typing/runtime primitives. No network calls or external SDKs/agents.
- **JSON as source of truth**: Derive all names, fields, node order, subgraph order, and graph name from the Target JSON.
- **Exact JSON reproduction**: Include a terminal node that assigns the **verbatim** Target JSON object to a state field (e.g., `state["target_json"] = <that dict>`) and marks status as `"Completed"`. Keys, values, and types must match exactly.
- **No leakage**: Do not import or replicate any external files or prior examples. Do not mention or embed any reference code.

## Required Behavior (map JSON → code)
1) **State definition**
   - Start with a typed state (e.g., `TypedDict`) containing at least:
     - `user_input: Union[str, Dict[str, Any], None]`
     - `current_node: int`
     - `status: str`
   - If `state_modifications.additional_fields` exists in the JSON, **add** those fields with the specified defaults and types.

2) **Additional functions**
   - If `additional_functions` exists, implement each function named there.
   - Follow its described `parameters`, `logic`, and which state fields it must set.
   - Example pattern: if a function’s logic says to parse `user_input` and set a state key, implement that parsing and set `current_node` and `status` accordingly.

3) **Action nodes from subgraphs**
   - For every subgraph under `subgraphs`, generate per-node functions using the JSON’s:
     - `function_name` (function name to define),
     - `type` (e.g., `click`, `wait`, `input`, `enter`, `double_click`, `screenshot`, `special`),
     - `description`,
     - `parameters`,
     - `order`.
   - **Default stub behavior (for non-special nodes)**: update `state["current_node"] = <order>` and `state["status"] = "Success"` and return the state.
   - **Disabled nodes**: if `disabled: true` is present, implement the function to simply `return state` without changing it.
   - **Screenshot nodes**: if present, also set `state["screenshot_url"]` to a deterministic placeholder (e.g., a static data URI string).

4) **Subgraph wiring**
   - Build each subgraph with `StateGraph(State)`; add nodes and **linear edges in ascending `order`** (from `__start__` to first node, then node→next node, and final node→`__end__`).
   - Use the subgraph name from the JSON.

5) **Main graph**
   - Add each compiled subgraph as a node in the main graph.
   - Respect `main_graph_flow.subgraph_order` to connect subgraphs linearly.
   - After the last subgraph, add a node (e.g., `produce_target_json`) that assigns the **exact** Target JSON object to `state["target_json"]` and sets `state["status"] = "Completed"`, then connect to `__end__`.
   - Compile the main graph with the name from `configuration.graph_name`.

6) **Generation instructions**
   - If the JSON includes a `generation_instructions` section (e.g., action type names, notes), use it **only** to decide node creation and naming; **do not** import any external templates or call any external functions.

## Implementation Details
- **Imports**: 
  - `from __future__ import annotations`
  - `import json`
  - `from typing import Union, Dict, Any, TypedDict`
  - `from langchain_core.runnables import RunnableConfig`
  - `from langgraph.graph import StateGraph`
- **Function signatures**: every node function must accept `(state: State, config: RunnableConfig) -> State`.
- **Naming**: use function and subgraph names exactly as in the JSON (`function_name`, subgraph key). Use simple, explicit names for any helper (e.g., `produce_target_json`).
- **No I/O**: no printing, logging, filesystem, or network operations.

## Output Format
- Output **only** the complete contents of `graph.py` (no fences, no comments, no explanations).

## Validation Checklist (the code you emit must satisfy all)
- [ ] The module imports successfully with no missing symbols.
- [ ] The `State` includes JSON-declared extra fields with defaults.
- [ ] All `additional_functions` exist and follow their described logic.
- [ ] Every subgraph node exists with the correct name and a deterministic body.
- [ ] Subgraphs and the main graph follow the exact linear order from the JSON.
- [ ] The compiled graph name equals `configuration.graph_name`.
- [ ] Running the terminal node sets `state["target_json"]` to the **exact** Target JSON and sets `status` to `"Completed"`.
